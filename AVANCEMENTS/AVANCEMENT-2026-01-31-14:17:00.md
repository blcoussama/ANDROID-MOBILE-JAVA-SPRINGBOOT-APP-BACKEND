‚óè ‚úÖ TU AS RAISON ! Les s√©quences d'auto-incr√©mentation sont toujours l√† !

  Quand tu supprimes les donn√©es avec DELETE, PostgreSQL ne r√©initialise PAS les compteurs AUTO_INCREMENT (appel√©s SEQUENCES).

  R√©sultat : Le prochain user aura ID=11, ID=12, etc. au lieu de ID=1, ID=2...

  ---
  üîß SOLUTION : R√©initialiser les s√©quences

  Commandes SQL √† ex√©cuter (tu es d√©j√† connect√©) :

  -- R√©initialiser les s√©quences (AUTO_INCREMENT) √† 1
  ALTER SEQUENCE users_id_seq RESTART WITH 1;
  ALTER SEQUENCE patient_id_seq RESTART WITH 1;
  ALTER SEQUENCE doctor_id_seq RESTART WITH 1;
  ALTER SEQUENCE appointment_id_seq RESTART WITH 1;
  ALTER SEQUENCE timeslot_id_seq RESTART WITH 1;
  ALTER SEQUENCE notification_id_seq RESTART WITH 1;

  Ex√©cute √ßa dans ton terminal PostgreSQL actuel.

  ---
  ‚úÖ V√âRIFICATION

  Apr√®s avoir ex√©cut√© les commandes ci-dessus, v√©rifie que c'est bien r√©initialis√© :

  -- V√©rifier les prochains IDs (doivent tous √™tre 1)
  SELECT currval('users_id_seq') AS users_next,
         currval('patient_id_seq') AS patient_next,
         currval('doctor_id_seq') AS doctor_next,
         currval('appointment_id_seq') AS appointment_next,
         currval('timeslot_id_seq') AS timeslot_next,
         currval('notification_id_seq') AS notification_next;

  Si erreur "currval not yet defined", c'est NORMAL (s√©quence pas encore utilis√©e depuis le reset). C'est bon signe ! ‚úÖ

  ---
  üìù SCRIPT COMPLET DE NETTOYAGE (pour le futur)

  Cr√©e un script SQL pour nettoyer rapidement :

  -- =====================================================
  -- SCRIPT DE NETTOYAGE COMPLET DATABASE
  -- =====================================================

  -- 1. Supprimer toutes les donn√©es (ordre inverse des FK)
  DELETE FROM notification;
  DELETE FROM appointment;
  DELETE FROM timeslot;
  DELETE FROM doctor;
  DELETE FROM patient;
  DELETE FROM users;

  -- 2. R√©initialiser les s√©quences AUTO_INCREMENT
  ALTER SEQUENCE users_id_seq RESTART WITH 1;
  ALTER SEQUENCE patient_id_seq RESTART WITH 1;
  ALTER SEQUENCE doctor_id_seq RESTART WITH 1;
  ALTER SEQUENCE appointment_id_seq RESTART WITH 1;
  ALTER SEQUENCE timeslot_id_seq RESTART WITH 1;
  ALTER SEQUENCE notification_id_seq RESTART WITH 1;

  -- 3. V√©rification
  SELECT 'Database cleaned and sequences reset!' AS status;

  Pour utiliser ce script :

# Sauvegarde dans un fichier

  nano ~/clean_db.sql

# Copie le script ci-dessus

# Ex√©cute avec

  PGPASSWORD=cabinetmed123 psql -h localhost -U cabinetmed_user -d cabinet_medical -f ~/clean_db.sql

  ---
  üöÄ MAINTENANT : Cr√©er les comptes de test proprement

  Une fois les s√©quences r√©initialis√©es, on va cr√©er 3 comptes de test :

  1. PATIENT (ID=1)

  -- User PATIENT
  INSERT INTO users (email, password_hash, role, first_name, last_name, phone, created_at)
  VALUES (
    '<patient@test.com>',
    '$2a$10$N9qo8uLOickgx2ZMRZoMy.2oXz0kO0Q0kO0Q0kO0Q0kO0Q0kO0Q0k.',
    'PATIENT',
    'Jean',
    'Dupont',
    '0612345678',
    NOW()
  );

  -- Patient li√© (r√©cup√®re l'ID du user cr√©√© ci-dessus)
  INSERT INTO patient (user_id, created_at)
  VALUES (currval('users_id_seq'), NOW());

  1. DOCTOR (ID=2)

  -- User DOCTOR
  INSERT INTO users (email, password_hash, role, first_name, last_name, phone, created_at)
  VALUES (
    '<doctor@test.com>',
    '$2a$10$N9qo8uLOickgx2ZMRZoMy.2oXz0kO0Q0kO0Q0kO0Q0kO0Q0kO0Q0k.',
    'DOCTOR',
    'Pierre',
    'Martin',
    '0698765432',
    NOW()
  );

  -- Doctor li√©
  INSERT INTO doctor (user_id, specialty, created_at)
  VALUES (currval('users_id_seq'), 'P√©diatre', NOW());

  1. ADMIN (ID=3)

  -- User ADMIN
  INSERT INTO users (email, password_hash, role, first_name, last_name, phone, created_at)
  VALUES (
    '<admin@test.com>',
    '$2a$10$N9qo8uLOickgx2ZMRZoMy.2oXz0kO0Q0kO0Q0kO0Q0kO0Q0kO0Q0k.',
    'ADMIN',
    'Sophie',
    'Dubois',
    '0688889999',
    NOW()
  );

  Tous les 3 utilisent le m√™me password hash = "Test123456"

  ---
  ‚ö†Ô∏è IMPORTANT : Le hash BCrypt

  Le hash que j'ai utilis√© ci-dessus est un EXEMPLE fictif.

  Pour g√©n√©rer le VRAI hash de "Test123456", tu dois :

  Option 1 : Via Spring Boot (RECOMMAND√â)

  Cr√©e un test rapide ou utilise l'app backend :

  // Dans un test JUnit ou main temporaire
  BCryptPasswordEncoder encoder = new BCryptPasswordEncoder();
  String hash = encoder.encode("Test123456");
  System.out.println(hash);

  Option 2 : Via inscription Android

  1. Inscris-toi avec l'app Android (email: <temp@test.com>, password: Test123456)
  2. Va voir dans la DB le hash g√©n√©r√© :
  SELECT password_hash FROM users WHERE email = '<temp@test.com>';
  3. Copie ce hash et utilise-le pour cr√©er DOCTOR et ADMIN

  ---
  üìã R√âCAPITULATIF - √âTAPES √Ä SUIVRE

  Dans PostgreSQL (tu es d√©j√† connect√©) :

  -- 1. R√©initialiser les s√©quences
  ALTER SEQUENCE users_id_seq RESTART WITH 1;
  ALTER SEQUENCE patient_id_seq RESTART WITH 1;
  ALTER SEQUENCE doctor_id_seq RESTART WITH 1;
  ALTER SEQUENCE appointment_id_seq RESTART WITH 1;
  ALTER SEQUENCE timeslot_id_seq RESTART WITH 1;
  ALTER SEQUENCE notification_id_seq RESTART WITH 1;

  -- 2. V√©rifier
  SELECT 'Sequences reset done!' AS status;

  Puis :

  A. Tu utilises l'app Android pour t'inscrire en tant que PATIENT (cr√©era ID=1)

  B. Tu copies le hash g√©n√©r√© et cr√©es manuellement DOCTOR (ID=2) et ADMIN (ID=3)

  OU

  A. Je te donne un hash BCrypt valide pour "Test123456" (mais tu devras le g√©n√©rer via Spring Boot)

  ---
  ‚ùì QUESTION

  Veux-tu que je :

  A. Te guide pour g√©n√©rer le hash BCrypt correct de "Test123456" (via petit test Java)

  B. On continue avec l'inscription Android pour g√©n√©rer le hash automatiquement

  C. Je te donne un script SQL complet avec hash (que tu testeras apr√®s)

  Dis-moi comment tu veux proc√©der ! üöÄ
